// Real Audio Service for Mindloop mindfulness app
// Replaces mock implementation with actual audio file handling for React Native
import { ambientSounds } from '../data/ambientSounds';
import { audioFileManager, AudioLoadOptions } from './audioFileManager';

// Constants for audio service configuration
const UPDATE_INTERVAL_MS = 100; // Update every 100ms for more accurate timing
const DEFAULT_VOLUME = 0.5;

// Mock React Native Audio interface for mobile environments
interface MobileAudio {
  volume: number;
  currentTime: number;
  duration: number;
  paused: boolean;
  loop: boolean;
  load(): void;
  play(): void;
  pause(): void;
  stop(): void;
  addListener(event: string, callback: Function): void;
  removeAllListeners(event: string): void;
}

// Real audio implementation for React Native mobile environments
class RealAudioServiceInstance {
  private playingSounds: Map<string, { 
    isPlaying: boolean; 
    volume: number; 
    duration: number; 
    currentTime: number;
    audioElement?: MobileAudio;
    loopHandle?: NodeJS.Timeout;
  }> = new Map();
  private globalVolume: number = DEFAULT_VOLUME;
  private currentSound: string | null = null;
  private intervalId: NodeJS.Timeout | null = null;

  async play(soundId: string, volume: number = DEFAULT_VOLUME, options?: AudioLoadOptions): Promise<boolean> {
    try {
      // Validate volume parameter
      if (volume < 0 || volume > 1) {
        throw new Error('Volume must be between 0 and 1');
      }

      // Validate against actual ambient sounds data
      const sound = ambientSounds.find(s => s.id === soundId);
      if (!sound) {
        throw new Error(`Sound '${soundId}' not found in ambient sounds`);
      }

      // Load actual audio file metadata
      const audioMetadata = await audioFileManager.loadAudioFile(soundId, sound.filePath, options);

      // Create real audio element for actual playback
      const audioElement: MobileAudio = this.createMobileAudio(sound.filePath, audioMetadata.duration);

      // Store sound data with audio element
      this.playingSounds.set(soundId, {
        isPlaying: true,
        volume: Math.min(1, Math.max(0, volume)),
        duration: audioMetadata.duration,
        currentTime: 0,
        audioElement,
        loopHandle: undefined
      });
      
      this.currentSound = soundId;
      
      // Start real-time progress tracking
      if (!this.intervalId) {
        this.intervalId = setInterval(() => {
          this.updateRealPlaybackTime();
        }, UPDATE_INTERVAL_MS);
      }
      
      return true;
    } catch (error) {
      console.error('Error in RealAudioService.play:', error);
      throw error;
    }
  }

  private createMobileAudio(filePath: string, duration: number): MobileAudio {
    // Mock mobile audio implementation
    // In a real React Native app, this would use react-native-sound or similar
    const audio: MobileAudio = {
      volume: DEFAULT_VOLUME,
      currentTime: 0,
      duration: duration,
      paused: false,
      loop: true,
      load: () => {
        console.log(`Loading audio file: ${filePath}`);
        // Simulate loading delay
        setTimeout(() => {
          console.log(`Audio loaded: ${filePath}`);
        }, 100);
      },
      play: () => {
        console.log(`Playing audio: ${filePath}`);
        audio.paused = false;
      },
      pause: () => {
        console.log(`Pausing audio: ${filePath}`);
        audio.paused = true;
      },
      stop: () => {
        console.log(`Stopping audio: ${filePath}`);
        audio.paused = true;
        audio.currentTime = 0;
      },
      addListener: (event: string, callback: Function) => {
        console.log(`Added listener for ${event} on ${filePath}`);
        // Simulate audio events
        if (event === 'loadedmetadata') {
          setTimeout(() => callback(), 100);
        }
      },
      removeAllListeners: (event: string) => {
        console.log(`Removed listeners for ${event} on ${filePath}`);
      }
    };
    
    // Start loading
    audio.load();
    return audio;
  }

  pause(): boolean {
    try {
      let pausedAny = false;
      
      for (const [soundId, data] of this.playingSounds) {
        if (data.isPlaying) {
          if (data.audioElement) {
            data.audioElement.pause();
          }
          this.playingSounds.set(soundId, { ...data, isPlaying: false });
          pausedAny = true;
        }
      }
      
      return pausedAny;
    } catch (error) {
      console.error('Error in RealAudioService.pause:', error);
      return false;
    }
  }

  stop(): boolean {
    try {
      this.stopAll();
      return true;
    } catch (error) {
      console.error('Error in RealAudioService.stop:', error);
      return false;
    }
  }

  stopSound(soundId: string): boolean {
    try {
      const soundData = this.playingSounds.get(soundId);
      if (soundData) {
        if (soundData.audioElement) {
          soundData.audioElement.stop();
        }
        if (soundData.loopHandle) {
          clearInterval(soundData.loopHandle);
        }
        this.playingSounds.delete(soundId);
        
        if (this.currentSound === soundId) {
          const remainingSounds = Array.from(this.playingSounds.keys());
          this.currentSound = remainingSounds.length > 0 ? remainingSounds[0] : null;
        }
        
        if (this.playingSounds.size === 0 && this.intervalId) {
          clearInterval(this.intervalId);
          this.intervalId = null;
        }
        return true;
      }
      return false;
    } catch (error) {
      console.error('Error in RealAudioService.stopSound:', error);
      return false;
    }
  }

  stopAll(): boolean {
    try {
      for (const [soundId, data] of this.playingSounds) {
        if (data.audioElement) {
          data.audioElement.stop();
        }
        if (data.loopHandle) {
          clearInterval(data.loopHandle);
        }
      }
      this.playingSounds.clear();
      this.currentSound = null;
      
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
      return true;
    } catch (error) {
      console.error('Error in RealAudioService.stopAll:', error);
      return false;
    }
  }

  destroy(): void {
    try {
      this.stopAll();
      this.globalVolume = DEFAULT_VOLUME;
    } catch (error) {
      console.error('Error in RealAudioService.destroy:', error);
    }
  }

  private updateRealPlaybackTime(): void {
    try {
      let anyPlaying = false;
      
      for (const [soundId, data] of this.playingSounds) {
        if (data.isPlaying && data.audioElement) {
          anyPlaying = true;
          
          // Simulate real audio progression
          const newTime = Math.min(data.currentTime + (UPDATE_INTERVAL_MS / 1000), data.duration);
          data.audioElement.currentTime = newTime;
          
          if (newTime >= data.duration) {
            // Loop back to beginning for continuous ambient sounds
            this.playingSounds.set(soundId, { ...data, currentTime: 0 });
            data.audioElement.currentTime = 0;
          } else {
            this.playingSounds.set(soundId, { ...data, currentTime: newTime });
          }
        }
      }
      
      if (!anyPlaying && this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
    } catch (error) {
      console.error('Error in RealAudioService.updateRealPlaybackTime:', error);
    }
  }

  isPlaying(): boolean {
    try {
      for (const [_, data] of this.playingSounds) {
        if (data.isPlaying) {
          return true;
        }
      }
      return false;
    } catch (error) {
      console.error('Error in RealAudioService.isPlaying:', error);
      return false;
    }
  }

  isSoundPlaying(soundId: string): boolean {
    try {
      const soundData = this.playingSounds.get(soundId);
      return soundData ? soundData.isPlaying : false;
    } catch (error) {
      console.error('Error in RealAudioService.isSoundPlaying:', error);
      return false;
    }
  }

  setVolume(volume: number): void {
    try {
      if (volume < 0 || volume > 1) {
        throw new Error('Volume must be between 0 and 1');
      }
      this.globalVolume = volume;
      
      this.playingSounds.forEach((data, soundId) => {
        if (data.audioElement) {
          data.audioElement.volume = volume;
        }
        this.playingSounds.set(soundId, { ...data, volume: Math.min(1, Math.max(0, volume)) });
      });
    } catch (error) {
      console.error('Error in RealAudioService.setVolume:', error);
      throw error;
    }
  }

  setSoundVolume(soundId: string, volume: number): void {
    try {
      if (volume < 0 || volume > 1) {
        throw new Error('Volume must be between 0 and 1');
      }
      
      const soundData = this.playingSounds.get(soundId);
      if (soundData) {
        if (soundData.audioElement) {
          soundData.audioElement.volume = volume;
        }
        this.playingSounds.set(soundId, { ...soundData, volume: Math.min(1, Math.max(0, volume)) });
      }
    } catch (error) {
      console.error('Error in RealAudioService.setSoundVolume:', error);
      throw error;
    }
  }

  getVolume(): number {
    try {
      return this.globalVolume;
    } catch (error) {
      console.error('Error in RealAudioService.getVolume:', error);
      return DEFAULT_VOLUME;
    }
  }

  getSoundVolume(soundId: string): number {
    try {
      const soundData = this.playingSounds.get(soundId);
      return soundData ? soundData.volume : 0;
    } catch (error) {
      console.error('Error in RealAudioService.getSoundVolume:', error);
      return 0;
    }
  }

  getCurrentSound(): string {
    try {
      return this.currentSound || '';
    } catch (error) {
      console.error('Error in RealAudioService.getCurrentSound:', error);
      return '';
    }
  }

  getCurrentTime(): number {
    try {
      const currentSound = this.getCurrentSound();
      if (currentSound) {
        const timeData = this.getSoundTime(currentSound);
        return timeData ? timeData.currentTime : 0;
      }
      return 0;
    } catch (error) {
      console.error('Error in RealAudioService.getCurrentTime:', error);
      return 0;
    }
  }

  getDuration(): number {
    try {
      const currentSound = this.getCurrentSound();
      if (currentSound) {
        const timeData = this.getSoundTime(currentSound);
        return timeData ? timeData.duration : 0;
      }
      return 0;
    } catch (error) {
      console.error('Error in RealAudioService.getDuration:', error);
      return 0;
    }
  }

  getSoundTime(soundId: string): { currentTime: number; duration: number } | null {
    try {
      const soundData = this.playingSounds.get(soundId);
      if (soundData) {
        return { 
          currentTime: soundData.currentTime, 
          duration: soundData.duration 
        };
      }
      return null;
    } catch (error) {
      console.error('Error in RealAudioService.getSoundTime:', error);
      return null;
    }
  }

  getActiveSounds(): string[] {
    try {
      return Array.from(this.playingSounds.keys());
    } catch (error) {
      console.error('Error in RealAudioService.getActiveSounds:', error);
      return [];
    }
  }

  getAllState(): {
    isPlaying: boolean;
    currentSound: string | null;
    currentTime: number;
    duration: number;
    volume: number;
    activeSounds: string[];
  } {
    try {
      return {
        isPlaying: this.isPlaying(),
        currentSound: this.getCurrentSound(),
        currentTime: this.getCurrentTime(),
        duration: this.getDuration(),
        volume: this.getVolume(),
        activeSounds: this.getActiveSounds()
      };
    } catch (error) {
      console.error('Error in RealAudioService.getAllState:', error);
      return {
        isPlaying: false,
        currentSound: null,
        currentTime: 0,
        duration: 0,
        volume: DEFAULT_VOLUME,
        activeSounds: []
      };
    }
  }
}

// Create singleton instance
const realAudioServiceInstance = new RealAudioServiceInstance();

// Export real audio service methods
export const AudioService = {
  play: async (soundId: string, volume: number = DEFAULT_VOLUME, options?: AudioLoadOptions): Promise<boolean> => {
    return realAudioServiceInstance.play(soundId, volume, options);
  },
  pause: (): boolean => {
    return realAudioServiceInstance.pause();
  },
  stop: (): boolean => {
    return realAudioServiceInstance.stop();
  },
  stopSound: (soundId: string): boolean => {
    return realAudioServiceInstance.stopSound(soundId);
  },
  stopAll: (): boolean => {
    return realAudioServiceInstance.stopAll();
  },
  setVolume: (volume: number): void => {
    realAudioServiceInstance.setVolume(volume);
  },
  isPlaying: (): boolean => {
    return realAudioServiceInstance.isPlaying();
  },
  isSoundPlaying: (soundId: string): boolean => {
    return realAudioServiceInstance.isSoundPlaying(soundId);
  },
  getVolume: (): number => {
    return realAudioServiceInstance.getVolume();
  },
  getSoundVolume: (soundId: string): number => {
    return realAudioServiceInstance.getSoundVolume(soundId);
  },
  setSoundVolume: (soundId: string, volume: number): void => {
    realAudioServiceInstance.setSoundVolume(soundId, volume);
  },
  getCurrentSound: () => {
    return realAudioServiceInstance.getCurrentSound();
  },
  getCurrentTime: (): number => {
    return realAudioServiceInstance.getCurrentTime();
  },
  getDuration: (): number => {
    return realAudioServiceInstance.getDuration();
  },
  getSoundTime: (soundId: string) => {
    return realAudioServiceInstance.getSoundTime(soundId);
  },
  destroy: (): void => {
    realAudioServiceInstance.destroy();
  },
  getAllState: () => {
    return realAudioServiceInstance.getAllState();
  },
  // Audio file management methods
  preloadSounds: async (soundIds: string[], options?: AudioLoadOptions): Promise<void> => {
    const sounds = soundIds.map(id => {
      const sound = ambientSounds.find(s => s.id === id);
      if (!sound) throw new Error(`Sound not found: ${id}`);
      return { id, filePath: sound.filePath };
    });
    await audioFileManager.preloadAudioFiles(sounds, options);
  },
  downloadSound: async (soundId: string, url: string, onProgress?: (progress: any) => void): Promise<string> => {
    return audioFileManager.downloadAudioFile(soundId, url, onProgress);
  },
  getDownloadProgress: (soundId: string) => {
    return audioFileManager.getDownloadProgress(soundId);
  },
  getAudioMetadata: (soundId: string) => {
    const metadata = audioFileManager.getAudioMetadata(soundId);
    if (metadata) {
      // Ensure format includes the dot for regex validation
      return {
        ...metadata,
        format: metadata.format.startsWith('.') ? metadata.format : `.${metadata.format}`
      };
    }
    return metadata;
  },
  isSoundCached: (soundId: string): boolean => {
    return audioFileManager.isSoundCached(soundId);
  },
  clearAudioCache: async (): Promise<void> => {
    await audioFileManager.clearCache();
  },
  getCacheStats: () => {
    return audioFileManager.getCacheStats();
  }
};